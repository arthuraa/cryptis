From stdpp Require Import base gmap.
From mathcomp Require Import ssreflect.
From iris.algebra Require Import agree auth csum gset gmap excl frac.
From iris.heap_lang Require Import notation proofmode.
From cryptis Require Import lib term cryptis primitives tactics session.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section PK.

Context `{!heapGS Σ, !cryptisG Σ}.
Notation iProp := (iProp Σ).

(** We are going to use the following naming conventions:

- [kI], [kR]: The identities of the initiator of the protocol and of the
  responder.  A nonce used to generate their key pair.

- [nI], [sI]: The private key generated by the initiator, and the corresponding
  key share.  In the case of a traditional NSL protocol, [sI = nI], so the
  private key is actually known to the responder.  In the case of a
  Diffie-Hellman exchange, the two will be different.

- [nR], [sR]: Similar, but for the responder.

- [kS]: A session key generated from the keying material exchanged by the
  parties. *)

Implicit Types (t kI kR nI nR sI sR kS : term).

Definition corruption kI kR : iProp :=
  pterm (TKey Dec kI) ∨ pterm (TKey Dec kR).

Global Instance corruptionC : Comm (⊣⊢) corruption.
Proof. by move=> k k'; rewrite /corruption [(_ ∨ _)%I]comm. Qed.

Variable N : namespace.

(** The following predicates describe various stages of the protocol. *)

(** [readable_by t k] *)
Definition readable_by t k : iProp :=
  □ (pterm (TKey Dec k) → pterm t).

#[global]
Instance readable_by_persistent t k : Persistent (readable_by t k).
Proof. apply _. Qed.

Definition secret_of t kI kR : iProp :=
  □ (pterm t ↔ ▷ corruption kI kR).

#[global]
Instance secret_of_persistent t kI kR : Persistent (secret_of t kI kR).
Proof. apply _. Qed.

(** [init_waiting kI kR nI sI] *)
Variable init_waiting : term → term → term → term → iProp.

(** [resp_accepted kI kR sI sR] *)
Variable resp_accepted : term → term → term → term → iProp.
Hypothesis resp_accepted_persistent :
  ∀ kI kR sI sR, Persistent (resp_accepted kI kR sI sR).

Definition maybe_resp_accepted kI kR sI sR : iProp :=
  corruption kI kR ∨ resp_accepted kI kR sI sR.

(** [resp_waiting kI kR sI nR sR] *)
Variable resp_waiting : term → term → term → term → term → iProp.

(** [init_finished sR] *)
Variable init_finished : term → iProp.
Hypothesis init_finished_persistent :
  ∀ sR, Persistent (init_finished sR).

Definition maybe_init_finished kI kR sR : iProp :=
  corruption kI kR ∨ init_finished sR.

(** [init_session kI kR kS] *)
Variable init_session : term → term → term → iProp.

Definition maybe_init_session kI kR kS : iProp :=
  corruption kI kR ∨ init_session kI kR kS.

(** [resp_session kI kR kS] *)
Variable resp_session : term → term → term → iProp.

Definition maybe_resp_session kI kR kS : iProp :=
  corruption kI kR ∨ resp_session kI kR kS.

Definition msg1_pred kR m1 : iProp :=
  ∃ sI kI,
    ⌜m1 = Spec.of_list [sI; TKey Enc kI]⌝ ∧
    pterm (TKey Enc kI) ∧
    readable_by sI kI.

Definition msg2_pred kI m2 : iProp :=
  ∃ sI sR kR,
    ⌜m2 = Spec.of_list [sI; sR; TKey Enc kR]⌝ ∧
    secret_of sR kI kR ∧
    resp_accepted kI kR sI sR.

Definition msg3_pred kR sR : iProp := init_finished sR.

Definition pk_auth_ctx : iProp :=
  enc_pred (N.@"m1") msg1_pred ∧
  enc_pred (N.@"m2") msg2_pred ∧
  enc_pred (N.@"m3") msg3_pred.

Lemma pk_auth_alloc E E' :
  ↑N ⊆ E →
  enc_pred_token E ={E'}=∗ pk_auth_ctx.
Proof.
iIntros (sub) "token".
rewrite (enc_pred_token_difference (↑N.@"m1") E); last solve_ndisj.
iDestruct "token" as "[t1 token]".
iMod (enc_pred_set (N.@"m1") msg1_pred with "t1") as "#H1" => //.
rewrite (enc_pred_token_difference (↑N.@"m2")); last solve_ndisj.
iDestruct "token" as "[t2 token]".
iMod (enc_pred_set (N.@"m2") msg2_pred with "t2") as "#H2" => //.
rewrite (enc_pred_token_difference (↑N.@"m3")); last solve_ndisj.
iDestruct "token" as "[t3 token]".
iMod (enc_pred_set (N.@"m3") msg3_pred with "t3") as "#H3" => //.
by iModIntro; do !iSplit => //.
Qed.

Global Instance persistent_pk_auth_ctx : Persistent pk_auth_ctx.
Proof. apply _. Qed.

Ltac protocol_failure :=
  by intros; wp_pures; iApply ("Hpost" $! None).

Definition pk_auth_init : val :=
  λ: "c" "gen_keys" "mk_sess_key" "skI" "pkI" "pkR",
  let: "nIsI" := "gen_keys" #() in
  let: "nI"   := Fst "nIsI" in
  let: "sI"   := Snd "nIsI" in
  let: "m1"   := tenc (N.@"m1") "pkR" (term_of_list ["sI"; "pkI"]) in
  send "c" "m1";;
  bind: "m2"   := tdec (N.@"m2") "skI" (recv "c") in
  bind: "m2"   := list_of_term "m2" in
  list_match: ["sI'"; "sR"; "pkR'"] := "m2" in
  assert: eq_term "sI'" "sI" && eq_term "pkR'" "pkR" in
  let: "k" := "mk_sess_key" "nI" "sR" in
  let: "m3" := tenc (N.@"m3") "pkR" "sR" in
  send "c" "m3";;
  SOME "k".

Definition pk_auth_resp : val :=
  λ: "c" "gen_keys" "mk_sess_key" "skR" "pkR",
  bind: "m1" := tdec (N.@"m1") "skR" (recv "c") in
  bind: "m1" := list_of_term "m1" in
  list_match: ["sI"; "pkI"] := "m1" in
  bind: "kt" := is_key "pkI" in
  assert: "kt" = repr Enc in
  let: "nRsR" := "gen_keys" #() in
  let: "nR" := Fst "nRsR" in
  let: "sR" := Snd "nRsR" in
  let: "m2" := tenc (N.@"m2") "pkI" (term_of_list ["sI"; "sR"; "pkR"]) in
  send "c" "m2";;
  bind: "m3" := tdec (N.@"m3") "skR" (recv "c") in
  assert: eq_term "m3" "sR" in
  let: "k" := "mk_sess_key" "sI" "nR" in
  SOME ("pkI", "k").

Lemma pterm_msg1I kI kR sI :
  pk_auth_ctx -∗
  sterm sI -∗
  pterm (TKey Enc kI) -∗
  pterm (TKey Enc kR) -∗
  secret_of sI kI kR -∗
  pterm (TEnc kR (Spec.tag (N.@"m1") (Spec.of_list [sI; TKey Enc kI]))).
Proof.
iIntros "(#m1P & _ & _) #s_sI #p_ekI #p_ekR #p_sI".
iApply pterm_TEncIS; eauto.
- by iApply pterm_sterm.
- iModIntro. iExists sI, kI. do !iSplit => //.
  iIntros "!> #?". iApply "p_sI". iModIntro. by iLeft.
- rewrite sterm_of_list /=. do !iSplit => //. by iApply pterm_sterm.
iIntros "!> #p_dkR". rewrite pterm_of_list /=. do !iSplit => //.
iApply "p_sI". iModIntro. by iRight.
Qed.

Lemma pterm_msg1E kI kR sI :
  pk_auth_ctx -∗
  pterm (TEnc kR (Spec.tag (N.@"m1") (Spec.of_list [sI; TKey Enc kI]))) -∗
  ▷ (sterm sI ∧ pterm (TKey Enc kI) ∧ readable_by sI kI).
Proof.
iIntros "(#m1P & _ & _) #p_m1".
iPoseProof (pterm_TEncE with "p_m1 m1P") as "{p_m1} [p_m1 | p_m1]".
- iModIntro. rewrite pterm_of_list /=.
  iDestruct "p_m1" as "(? & ? & ? & _)". iSplit => //.
    by iApply pterm_sterm.
  iSplit; eauto.
  by iIntros "!> ?".
- iDestruct "p_m1" as "(#p_m1 & #s_m1 & _)".
  iModIntro.
  iDestruct "p_m1" as "(%sI' & %kI' & %e_m1 & ? & ?)".
  case/Spec.of_list_inj: e_m1 => <- <-.
  rewrite sterm_of_list /=. iDestruct "s_m1" as "(#s_sI & _)".
  do !iSplit => //.
Qed.

Lemma pterm_msg2I kI kR sI sR :
  pk_auth_ctx -∗
  pterm (TKey Enc kI) -∗
  pterm (TKey Enc kR) -∗
  sterm sI -∗
  readable_by sI kI -∗
  sterm sR -∗
  secret_of sR kI kR -∗
  resp_accepted kI kR sI sR -∗
  pterm (TEnc kI (Spec.tag (N.@"m2") (Spec.of_list [sI; sR; TKey Enc kR]))).
Proof.
iIntros "(_ & #? & _) #p_eI #p_eR #s_sI #p_sI #s_sR #p_sR #accepted".
iApply pterm_TEncIS; eauto.
- by iApply pterm_sterm.
- iModIntro. iExists sI, sR, kR. by eauto.
- rewrite sterm_of_list /=. do ![iSplit => //].
  by iApply pterm_sterm.
iIntros "!> #p_dkI". rewrite pterm_of_list /=. do !iSplit => //.
- by iApply "p_sI".
- iApply "p_sR". iModIntro. by iLeft.
Qed.

Lemma pterm_msg2E kI kR sI sR :
  pk_auth_ctx -∗
  secret_of sI kI kR -∗
  pterm (TEnc kI (Spec.tag (N.@"m2") (Spec.of_list [sI; sR; TKey Enc kR]))) -∗
  ▷ (sterm sR ∧ secret_of sR kI kR ∧ maybe_resp_accepted kI kR sI sR).
Proof.
iIntros "(_ & #m2P & _) #started #p_m2".
iPoseProof (pterm_TEncE with "p_m2 m2P") as "{p_m2} [p_m2 | p_m2]".
- rewrite pterm_of_list /=.
  iDestruct "p_m2" as "(? & p_sI & p_sR & _ & _)".
  iSpecialize ("started" with "p_sI").
  iModIntro.
  iSplit; first by iApply pterm_sterm.
  iSplit.
    iModIntro. by iSplit; eauto.
  by iLeft.
- iDestruct "p_m2" as "(#p_m2 & #s_m2 & #?)". rewrite sterm_of_list /=.
  iModIntro.
  iDestruct "p_m2" as "(%sI' & %sR' & %kR' & %e_m2 & sRP & ?)".
  iDestruct "s_m2" as "(s_sI & s_sR & _)".
  case/Spec.of_list_inj: e_m2 => <- <- <-.
  do !iSplit => //.
  by iRight.
Qed.

Lemma pterm_msg3I kI kR sI sR :
  pk_auth_ctx -∗
  pterm (TKey Enc kR) -∗
  sterm sR -∗
  secret_of sR kI kR -∗
  init_finished sR -∗
  pterm (TEnc kR (Spec.tag (N.@"m3") sR)).
Proof.
iIntros "(_ & _ & #p_m3) #p_eR #s_sR #p_sR #finished".
iApply pterm_TEncIS => //.
  by iApply pterm_sterm.
iIntros "!> #p_dkR". iApply "p_sR". by iRight.
Qed.

Lemma pterm_msg3E kI kR sR :
  pk_auth_ctx -∗
  secret_of sR kI kR -∗
  pterm (TEnc kR (Spec.tag (N.@"m3") sR)) -∗
  ▷ maybe_init_finished kI kR sR.
Proof.
iIntros "(_ & _ & #?) #p_sR #p_m3".
iDestruct (pterm_TEncE with "p_m3 [//]") as "{p_m3} [p_m3|p_m3]".
- iDestruct "p_m3" as "[_ p_m3]". iLeft. by iApply "p_sR".
- iDestruct "p_m3" as "(#p_m3 & _)". by iRight.
Qed.

Implicit Types Ψ : val → iProp.

Variable init_gen_keys : val.
Hypothesis wp_init_gen_keys : ∀ E kI kR,
  {{{ True }}}
    init_gen_keys #() @ E
  {{{ nI sI, RET (nI, sI);
      sterm nI ∧ sterm sI ∧
      secret_of sI kI kR ∧
      init_waiting kI kR nI sI }}}.

Variable init_mk_sess_key : val.
Hypothesis wp_init_mk_sess_key : ∀ E kI kR nI sI sR,
  maybe_resp_accepted kI kR sI sR -∗
  {{{ init_waiting kI kR nI sI }}}
    init_mk_sess_key nI sR @ E
  {{{ kS, RET (kS : val);
      sterm kS ∧
      secret_of kS kI kR ∧
      init_finished sR ∧
      maybe_init_session kI kR kS }}}.

Lemma wp_pk_auth_init c kI kR E :
  ↑cryptisN ⊆ E →
  ↑N ⊆ E →
  channel c -∗
  pk_auth_ctx -∗
  pterm (TKey Enc kI) -∗
  pterm (TKey Enc kR) -∗
  {{{ True }}}
    pk_auth_init c init_gen_keys init_mk_sess_key
    (TKey Dec kI) (TKey Enc kI) (TKey Enc kR) @ E
  {{{ okS, RET (repr okS);
      if okS is Some kS then
        sterm kS ∧ secret_of kS kI kR ∧ maybe_init_session kI kR kS
      else True }}}.
Proof.
rewrite /pk_auth_init.
iIntros (??) "#chan_c #ctx #p_kI #p_kR %Ψ !> _ Hpost".
wp_pures.
wp_bind (init_gen_keys _). iApply (wp_init_gen_keys _ kI kR); eauto.
iIntros "!> %nI %sI (#s_nI & #s_sI & #p_sI & waiting)".
wp_pures. wp_list. wp_term_of_list. wp_tenc => /=. wp_pures.
wp_bind (send _ _). iApply wp_send; eauto.
  by iApply pterm_msg1I.
wp_pures. wp_bind (recv _). iApply wp_recv; eauto.
iIntros "%m2 #p_m2". wp_tdec m2; last protocol_failure.
wp_list_of_term m2; last protocol_failure.
wp_list_match => [sI' sR pkR' {m2} ->|_]; last protocol_failure.
wp_eq_term e; last protocol_failure; subst sI'.
wp_eq_term e; last protocol_failure; subst pkR'.
iPoseProof (pterm_msg2E with "[//] [//] [//]")
  as "{p_m2} (s_sR & p_sR & accepted)".
wp_pures. wp_bind (init_mk_sess_key _ _).
iApply (wp_init_mk_sess_key with "[//] [waiting]") => //.
iIntros "!> %kS (#s_kS & #p_kS & #finished & session)".
wp_pures. wp_tenc. wp_pures. wp_bind (send _ _). iApply wp_send; eauto.
  by iApply pterm_msg3I.
wp_pures.
by iApply ("Hpost" $! (Some kS)); eauto.
Qed.

Variable resp_gen_keys : val.
Hypothesis wp_resp_gen_keys :
  ∀ E kI kR sI,
    {{{ True }}}
      resp_gen_keys #() @ E
    {{{ nR sR, RET (nR, sR);
        sterm nR ∧
        sterm sR ∧
        secret_of sR kI kR ∧
        resp_accepted kI kR sI sR ∧
        resp_waiting kI kR sI nR sR }}}.

Variable resp_mk_sess_key : val.
Hypothesis wp_resp_mk_sess_key :
  ∀ E kI kR sI nR sR,
    maybe_init_finished kI kR sR -∗
    {{{ resp_waiting kI kR sI nR sR }}}
      resp_mk_sess_key sI nR @ E
    {{{ kS, RET (repr kS);
        sterm kS ∧
        secret_of kS kI kR ∧
        maybe_resp_session kI kR kS }}}.

Lemma wp_pk_auth_resp c kR E :
  ↑cryptisN ⊆ E →
  ↑N ⊆ E →
  channel c -∗
  pk_auth_ctx -∗
  pterm (TKey Enc kR) -∗
  {{{ True }}}
    pk_auth_resp c resp_gen_keys resp_mk_sess_key
    (TKey Dec kR) (TKey Enc kR) @ E
  {{{ res, RET (repr res);
      if res is Some (pkI, kS) then
         ∃ kI, ⌜pkI = TKey Enc kI⌝ ∧
               pterm pkI ∧
               sterm kS ∧
               secret_of kS kI kR ∧
               maybe_resp_session kI kR kS
       else True }}}.
Proof.
iIntros (??) "#? #ctx #e_kR %Ψ !> _ Hpost".
rewrite /pk_auth_resp; wp_pures.
wp_bind (recv _); iApply wp_recv => //; iIntros (m1) "#Hm1".
wp_tdec m1; last protocol_failure.
wp_list_of_term m1; last protocol_failure.
wp_list_match => [sI pkI {m1} ->|_]; last protocol_failure.
wp_is_key_eq kt kI et; last protocol_failure; subst pkI.
wp_pures.
case: (bool_decide_reflect (_ = repr_key_type Enc)); last protocol_failure.
case: kt => // _.
wp_pures.
iDestruct (pterm_msg1E with "[] Hm1") as "{Hm1} (s_sI & p_eI & p_sI)"; eauto.
wp_bind (resp_gen_keys _). iApply (wp_resp_gen_keys _ kI kR sI) => //.
iIntros "!> %nR %sR (#s_nR & #s_sR & #p_sR & #accepted & waiting)".
wp_pures. wp_list; wp_term_of_list. wp_tenc. wp_pures.
wp_bind (send _ _). iApply wp_send => //.
  iApply pterm_msg2I; eauto.
wp_pures. wp_bind (recv _). iApply wp_recv => //.
iIntros "%m3 #p_m3". wp_tdec m3; last protocol_failure.
wp_eq_term e; last protocol_failure; subst m3.
iPoseProof (pterm_msg3E with "[//] [//] [//]") as "finished".
wp_pures. wp_bind (resp_mk_sess_key _ _).
iApply (wp_resp_mk_sess_key with "[//] [waiting]"); eauto.
iIntros "!> %kS (#s_kS & #p_kS & session)". wp_pures. iModIntro.
iApply ("Hpost" $! (Some (TKey Enc kI, kS))). iExists kI. by eauto.
Qed.

End PK.
