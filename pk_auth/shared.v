From stdpp Require Import base gmap.
From mathcomp Require Import ssreflect.
From iris.algebra Require Import agree auth csum gset gmap excl frac.
From iris.algebra Require Import reservation_map.
From iris.heap_lang Require Import notation proofmode.
From cryptis Require Import lib term cryptis primitives tactics.
From cryptis Require Import role session.

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.

Section PK.

Context `{!heapGS Σ, !cryptisGS Σ, !sessionGS Σ}.
Notation iProp := (iProp Σ).

Implicit Types (rl : role) (t nI nR sI sR kS : term).
Implicit Types (skI skR : aenc_key).

Variable N : namespace.

(** We are going to use the following naming conventions:

- [skI], [skR]: The identities of the initiator of the protocol and of the
  responder.

- [nI], [sI]: The private key generated by the initiator, and the corresponding
  key share.  In the case of a traditional NSL protocol, [sI = nI], so the
  private key is actually known to the responder.  In the case of a
  Diffie-Hellman exchange, the two will be different.

- [nR], [sR]: Similar, but for the responder.

- [kS]: A session key generated from the keying material exchanged by the
  parties. *)

Definition corruption skI skR : iProp :=
  public skI ∨ public skR.

Global Instance corruptionC : Comm (⊣⊢) corruption.
Proof. by move=> k k'; rewrite /corruption [(_ ∨ _)%I]comm. Qed.

Global Instance corruption_persistent skI skR :
  Persistent (corruption skI skR).
Proof. apply _. Qed.

Definition in_honest skI skR (T : gset term) : bool :=
  bool_decide (skI ∈ T ∧ skR ∈ T).

Definition readable_by t skI skR : iProp :=
  □ (corruption skI skR → public t).

#[global]
Instance readable_by_persistent t skI skR : Persistent (readable_by t skI skR).
Proof. apply _. Qed.

Definition secret_of t skI skR : iProp :=
  □ (public t ↔ ▷ corruption skI skR).

#[global]
Instance secret_of_persistent t skI skR : Persistent (secret_of t skI skR).
Proof. apply _. Qed.

Class PK := {
  is_priv_key : term → aenc_key → aenc_key → iProp;

  mk_key_share : term → term;

  mk_key_share_inj : Inj (=) (=) mk_key_share;

  mk_key_share_minted :
    ∀ n, minted (mk_key_share n) ⊣⊢ minted n;

  mk_key_share_secret_of :
    ∀ n skI skR, minted n -∗ is_priv_key n skI skR -∗
    secret_of (mk_key_share n) skI skR;

  mk_session_key : role → term → term → term;

  mk_session_key_elem_of :
    ∀ rl1 rl2 n1 n1' n2 s2',
      mk_session_key rl1 n1  (mk_key_share n2) =
      mk_session_key rl2 n1' s2' →
      n1' = n1 ∧ s2' = mk_key_share n2 ∨
      n1' = n2 ∧ s2' = mk_key_share n1;

  mk_session_keyC :
    ∀ nI nR, mk_session_key Init nI (mk_key_share nR) =
             mk_session_key Resp nR (mk_key_share nI);

  mk_session_key_minted :
    ∀ rl t1 t2, minted t1 -∗ minted t2 -∗ minted (mk_session_key rl t1 t2);

  confirmation : role → aenc_key → aenc_key → term → iProp;

  mk_key_share_impl : val;
  wp_mk_key_share : ∀ kI kR,
    {{{ cryptis_ctx }}}
      mk_key_share_impl #()
    {{{ (n : term), RET (n, mk_key_share n) : val;
        minted n ∗ □ is_priv_key n kI kR ∗
        term_token n ⊤
    }}};

  mk_session_key_impl : role → val;
  wp_mk_session_key : ∀ rl (n s : term),
    {{{ True }}}
      mk_session_key_impl rl n s
    {{{ RET mk_session_key rl n s : val; True}}};

}.

#[global] Existing Instance mk_key_share_inj.

Context `{!PK}.

Definition init_confirm skI skR : iProp := ∀ nI sR,
  let kS := mk_session_key Init nI sR in
  |==> □ confirmation Init skI skR kS.

Definition resp_confirm skR : iProp := ∀ skI sI nR,
  let kS := mk_session_key Resp nR sI in
  |==> □ confirmation Resp skI skR kS.

Implicit Types ks : aenc_key * aenc_key.

Definition session_ress rl nI nR ks : iProp :=
  let '(skI, skR) := ks in
  □ confirmation rl skI skR (mk_session_key Init nI (mk_key_share nR)) ∧
  if rl is Init then term_token nI (↑N.@"resp")
  else True.

Definition session_weak' skI skR t : iProp :=
  term_meta t (N.@"success") (skI, skR).

#[global]
Instance session_weak'_persistent skI skR t :
  Persistent (session_weak' skI skR t).
Proof. apply _. Qed.

Lemma session_weak'_agree kI1 kI2 kR1 kR2 t :
  session_weak' kI1 kR1 t -∗
  session_weak' kI2 kR2 t -∗
  ⌜kI1 = kI2 ∧ kR1 = kR2⌝.
Proof.
iIntros "#meta1 #meta2".
iPoseProof (term_meta_agree with "meta1 meta2") as "%e".
case: e => -> ->. iSplit => //.
Qed.

Definition init_started skI skR sI : iProp :=
  public sI ∨
  ∃ nI,
    ⌜sI = mk_key_share nI⌝ ∗
    session_weak' skI skR nI ∗
    □ is_priv_key nI skI skR.

Lemma session_weak'_set skI skR t :
  term_token t (↑N.@"success") ==∗
  session_weak' skI skR t.
Proof.
iIntros "token".
by iApply term_meta_set.
Qed.

Definition session_weak rl skI skR kS : iProp :=
  ∃ n s, ⌜kS = mk_session_key rl n s⌝ ∗
  session_weak' skI skR n.

#[global]
Instance session_weak_persistent rl skI skR kS :
  Persistent (session_weak rl skI skR kS).
Proof. apply _. Qed.

Definition msg1_pred skR m1 : iProp :=
  ∃ sI skI,
    ⌜m1 = Spec.of_list [sI; Spec.pkey skI]⌝ ∧
    readable_by sI skI skR ∧
    init_started skI skR sI.

Definition resp_accepted skI skR sI sR : iProp :=
  public sI ∨
  ∃ nI nR,
    session_weak' skI skR nI ∧
    session_weak' skI skR nR ∧
    ⌜sI = mk_key_share nI⌝ ∧
    ⌜sR = mk_key_share nR⌝ ∧
    □ is_priv_key nR skI skR ∧
    □ confirmation Resp skI skR (mk_session_key Init nI (mk_key_share nR)) ∧
    session (N.@"session") Resp nI nR (skI, skR).

Definition resp_waiting skI skR sI nR : iProp :=
  public sI ∗ term_token nR (↑N.@"session") ∨
  ∃ nI,
    ⌜sI = mk_key_share nI⌝ ∧
    session (N.@"session") Resp nI nR (skI, skR) ∧
    □ confirmation Resp skI skR (mk_session_key Init nI (mk_key_share nR)) ∧
    waiting_for_peer (N.@"session") session_ress Resp nI nR (skI, skR).

Definition msg2_pred skI m2 : iProp :=
  ∃ sI sR skR,
    ⌜m2 = Spec.of_list [sI; sR; Spec.pkey skR]⌝ ∧
    secret_of sR skI skR ∧
    resp_accepted skI skR sI sR.

Definition init_finished skR sR : iProp :=
  public sR ∨
  ∃ nI nR skI,
    session_weak' skI skR nI ∧
    session_weak' skI skR nR ∧
    ⌜sR = mk_key_share nR⌝ ∧
    □ is_priv_key nI skI skR ∧
    □ is_priv_key nR skI skR ∧
    □ confirmation Init skI skR (mk_session_key Init nI (mk_key_share nR)) ∧
    session (N.@"session") Init nI nR (skI, skR) ∧
    session (N.@"session") Resp nI nR (skI, skR).

Definition msg3_pred := init_finished.

Definition session_key_meta_token skI skR kS E : iProp :=
  ∃ nI nR,
    ⌜kS = mk_session_key Init nI (mk_key_share nR)⌝ ∗
    session (N.@"session") Init nI nR (skI, skR) ∗
    session (N.@"session") Resp nI nR (skI, skR) ∗
    term_token nI E.

Definition session_key_meta skI skR `{Countable L} kS N' (x : L) : iProp :=
  ∃ nI nR γ,
    ⌜kS = mk_session_key Init nI (mk_key_share nR)⌝ ∗
    session (N.@"session") Init nI nR (skI, skR) ∗
    session (N.@"session") Resp nI nR (skI, skR) ∗
    term_meta nI N' x.

Lemma mk_session_key_inj nI nR nI' nR' skI skR :
  mk_session_key Init nI  (mk_key_share nR) =
  mk_session_key Init nI' (mk_key_share nR') →
  session (N.@"session") Init nI nR (skI, skR) -∗
  session (N.@"session") Resp nI' nR' (skI, skR) -∗
  ⌜nI' = nI⌝.
Proof.
move=> /mk_session_key_elem_of [] [-> /mk_key_share_inj ->]; first by eauto.
iIntros "sessI sessR".
by iDestruct (session_role_agree with "sessI sessR") as "[]".
Qed.

Definition session_key skI skR kS : iProp :=
  ∃ nI nR,
    ⌜kS = mk_session_key Init nI (mk_key_share nR)⌝ ∗
    session_weak' skI skR nI ∗
    session_weak' skI skR nR ∗
    □ is_priv_key nI skI skR ∗
    □ is_priv_key nR skI skR ∗
    □ confirmation Init skI skR kS ∧
    □ confirmation Resp skI skR kS ∧
    session (N.@"session") Init nI nR (skI, skR) ∗
    session (N.@"session") Resp nI nR (skI, skR).

Global Instance session_key_persistent skI skR kS :
  Persistent (session_key skI skR kS).
Proof. apply _. Qed.

Lemma session_weak_session_key rl kI1 kI2 kR1 kR2 kS :
  session_weak rl kI1 kR1 kS -∗
  session_key kI2 kR2 kS -∗
  ⌜kI1 = kI2 ∧ kR1 = kR2⌝.
Proof.
iIntros "(%t1 & %t2 & %e1 & #sess1)".
iIntros "(%nI & %nR & %e2 & #sessI & #sessR & _)".
rewrite e2 in e1.
case/mk_session_key_elem_of: e1 => [] [-> e].
- by iApply (session_weak'_agree with "sess1 sessI").
- by iApply (session_weak'_agree with "sess1 sessR").
Qed.

Lemma session_key_confirmation rl skI skR kS :
  session_key skI skR kS -∗
  confirmation rl skI skR kS.
Proof.
iIntros "(% & % & % & _ & _ & _ & _ & #? & #? & _)".
by case: rl.
Qed.

Definition pk_auth_ctx : iProp :=
  session_ctx (N.@"session") session_ress ∧
  aenc_pred (N.@"m1") msg1_pred ∧
  aenc_pred (N.@"m2") msg2_pred ∧
  aenc_pred (N.@"m3") msg3_pred.

Lemma pk_auth_alloc E1 E2 E' :
  ↑N ⊆ E1 →
  ↑N ⊆ E2 →
  session_token E1 -∗
  seal_pred_token AENC E2 ={E'}=∗
  pk_auth_ctx ∗
  session_token (E1 ∖ ↑N) ∗
  seal_pred_token AENC (E2 ∖ ↑N).
Proof.
iIntros (sub1 sub2) "t1 t2".
rewrite (session_token_difference (↑N) E1) //. iDestruct "t1" as "[t1 t1']".
iMod (session_alloc (N.@"session") session_ress with "t1")
  as "[#H0 t1]"; try solve_ndisj.
rewrite (seal_pred_token_difference _ (↑N)) //.
iDestruct "t2" as "[t2 t2']".
iMod (aenc_pred_set (N := N.@"m1") msg1_pred with "t2")
  as "[#H1 t2]"; try solve_ndisj.
iMod (aenc_pred_set (N := N.@"m2") msg2_pred with "t2")
  as "[#H2 t2]"; try solve_ndisj.
iMod (aenc_pred_set (N := N.@"m3") msg3_pred with "t2")
  as "[#H3 t2]"; try solve_ndisj.
iModIntro; iFrame; do !iSplit => //.
Qed.

Global Instance persistent_ctx : Persistent pk_auth_ctx.
Proof. apply _. Qed.

End PK.
