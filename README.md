# Cryptis: Cryptographic Reasoning in Separation Logic

This artifact accompanies the POPL 2026 paper "Cryptis: Cryptographic Reasoning
in Separation Logic".

## Browsing the development with a virtual machine

For your convenience, this artifact is available under a virtual machine with
all the required dependencies pre-installed.  The VM runs under VirtualBox
7.1. After turning on the VM, you can log in with the username "cryptis" and the
password "cryptis".

The directory with the Cryptis development is shown in the Desktop.  To compile
the code, follow these steps:

1. Open a terminal by clicking on the bar icon on the top-left corner of the
   screen, typing "terminal" and hitting "enter".
   
2. Go to the Cryptis directory by running `cd Cryptis`.  This will set up an
   environment with all the required dependencies.
   
3. You can compile the development with `make` (see below for more information).
   After compiling the development, you can also run the proofs interactively
   with Emacs.  Run `emacs <path-to-rocq-file>` from the same terminal window.
   This will launch Emacs with the Proof General extension enabled.  When the
   file is opened, you can use the icons displayed on the menu bar to step
   through the file.
   
## Setting up your own environment

Alternatively, you can download the Cryptis development directly from the
`popl-2026-artifact` branch of the Cryptis repository
(https://github.com/arthuraa/cryptis).  Cryptis is known to compile with the
following dependencies:

- rocq-prover v9.0.0
- rocq-mathcomp-ssreflect v2.4.0
- coq-deriving v0.2.2
- coq-iris v4.4.0
- coq-iris-heap-lang v4.4.0

There are two recommended ways to install the dependencies: via Nix or opam.

### Nix

If you have Nix flakes enabled, the accompanying `flake.nix` file should be
enough to install all the required dependencies.  Simply run `nix develop`.

### opam

Make sure to add the Rocq opam repository to your switch:

```
opam repo add rocq-released https://rocq-prover.org/opam/released
```

Afterwards, Cryptis can be installed with:

```
opam install .
```

Alternatively, run `make builddep` to produce and install a dummy package that
installs the correct dependencies.

## Building and checking proofs

After setting up the required dependencies, simply run `make`.  We recommend
using `make -j` to enable parallel compilation.  If everything goes well, `make`
should run until completion, and the last file `summary/summary.v` should print
"Closed under the global context." three times, indicating that the security
results for the main case studies in the paper are free of axioms and
assumptions.

### Generating Statistics in Figure 17

Run the script `./stats.sh` in the working directory.  This will clean all the
object files generated by Rocq, then compile the code comprising each row of the
table.  The result will be output in `table.tex`.

Note: the compilation times for the paper were measured using eight parallel
jobs.  By default, the script will only run one job at a time.

## List of claims made in the paper

The file `summary/summary.v` lists all the theorems and rules claimed in the
paper. These results are grouped by the section where appear in the paper. You
can run this through this file interactively after compiling the development.

The Cryptis development differs in a few ways from the paper presentation.  We
list the most salient differences below for ease of reference.  The following
table summarizes how the notations in the paper map to Rocq definitions.

| Paper notation | Rocq equivalent                         |
|----------------|-----------------------------------------|
| `t ^ t1 .. tn` | `TExpN t [t1; ..; tn]`                  |
| `F ↦N φ`       | `seal_pred F N φ` (when `F` is generic) |
| `aenc ↦N φ`    | `aenc_pred N φ`                         |
| `sign ↦N φ`    | `sign_pred N φ`                         |
| `senc ↦N φ`    | `senc_pred N φ`                         |
| `token F E`    | `seal_pred_token F E`                   |
| `t ↦N x`       | `term_meta t N x`                       |
| `token t E`    | `term_token t E`                        |
| `t ↦db ot'`    | `db_mapsto` or `db_free`                |


### Minted terms

On paper, we assume that the user can only refer to terms that contain nonces
and keys that have already been generated.  In Rocq, we cannot impose this
restriction, because the definition of the term datatype contains all terms,
whether they have been generated or not.  Instead, we add a special `minted t`
predicate to several lemmas, which holds precisely when the term `t` only
contains nonces that have already been generated.

### Invariants and explicit channels

In Rocq, the `send` and `recv` functions must take an explicit channel parameter
`c`.  Functions that manipulate the network must assume that c is a valid
channel in their preconditions.  To run a program `f` from the initial state, we
must pass it to the `run_network` function, which allocates a new channel `c`,
initializes the attacker threads that control `c`, and then passes `c` to `f`
(cf. the `cryptis_adequacy` theorem in `summary/summary.v`).  Moreover, most
programs require a special `cryptis_ctx` invariant to hold, which is also given
by the adequacy theorem.

### Confidentiality of Diffie-Hellman terms

The Rocq development uses a more general definition of `public` for
Diffie-Hellman terms than the one in the paper.  The paper rules hold for any DH
private key that satisfies the `dh_key` predicate.  As shown by the
`wp_mk_nonce` specification in `summary/summary.v`, any nonce can be allocated
to satisfy this property.

### Types for keys

Our Rocq development uses separate types `aenc_key`, `sign_key` and `senc_key`
to describe private keys for asymmetric encryption, signature keys, and
symmetric encryption keys.  In paper, we tacitly assume that quantifiers that
range over key terms are of this form.

### ISO

The Rocq development proves the strong specifications of Section 5.1 directly,
and then derives the weaker ones.  Because of this, the signature predicates
that we use (`examples/iso_dh/proofs/base.v`) are a bit different from what
appears in Fig. 10.

One minor difference between the weak specifications and the one given in
Theorem 5.1 is that the latter provides a full token for each key share, whereas
the former must consume part of the token.  This is because the weak
specifications are proved using the strong ones, and the strong specifications
require using part of the metadata token to create the release tokens.

### Reliable connections

The implementation of the `recv` function is a bit different from what is shown
in Figure 13: it is based on a more general `select` function that allows an
agent to invoke a different handler depending on the type of message that it
received.  The reason for having `select` as a primitive instead of `recv` is
that it simplifies the server logic of the RPC functionality: we just need to
specify how each type of call is handled.

### Remote procedure calls

The specifications of `call` and `close` are the same as those on paper, except
for some auxiliary definitions that were inlined in the paper for space reasons.
The development also has the specifications for the server functions, which were
omitted from the paper.  In particular, the `wp_server` function says that a
connected server can initiate a loop where it awaits for calls from the client
on the other end of the connection, provided that the server has correct
handlers for all the calls it wants to respond to.

### Key-value store

The paper uses a single points-to resource to describe the state of each key,
regardless of whether the key is present in the database or not.  In Rocq, this
notation corresponds to two resources: `db_mapsto skC skS t t'` says that the
key `t` is mapped to the value `t'`, and `db_free skC skS T` says that no term
`t ∈ T` is present in the database.

The game in Figure 6 is also a bit different: the paper version was split into
two functions to better fit the page.

## Structure of the rest of the development

### Core Library

The `cryptis` directory contains the main components of the Cryptis logic.

- `lib/*, lib.v`: General additions to Iris and MathComp.  List manipulation
  programs for HeapLang.
- `core/*`, `cryptis.v`: Core Cryptis components: cryptographic terms, the
  `public` predicate, encryption predicates, and term metadata.
- `primitives/*`, `primitives.v`: HeapLang functions for manipulating
  cryptographic terms.  Definition of the attacker.
- `tactics.v`: Ltac tactics for symbolically executing the main HeapLang
  functions on terms.

### Case studies

In `examples` you will find the code for our case studies in separate
directories:

- `nsl`: NSL protocol.
- `iso_dh`: ISO protocol with DH key exchange and digital signatures.
- `conn`: Authenticated connections.
- `rpc`: Remote procedure calls.
- `store`: Authenticated key-value store.

Each case study is structured as follows:

- `impl.v`: Implementation in HeapLang.
- `proofs/*`, `proofs.v`: Proofs of correctness using the Cryptis logic.
- `game.v`: Security based on a symbolic game (for `nsl`, `iso_dh` and `store`).


